# Gadget Pipeline

This pipeline template is designed for deploying AI models on the LMI runtime platform - **Gadget**. It also provides a step-by-step guide to help developers get started.

## Getting Started

1. Read this document.
2. Learn the pipeline examples in the **example** folder.
3. Define the **Dockerfile** for your pipeline.
4. Populate the **pipeline_def.json** and **../static_models/manifest.json** with the necessary configurations.
5. Follow the [how-to tutorial](https://github.com/lmitechnologies/Gadget_Inspection_Template/blob/main/pipeline/how-to.md) to implement the required functions and implement a unit test in the `main` function within **pipeline_class.py**.
7. Run and validate the unit test.

## Top-level Folder Strcuture

The pipeline folder consists of the following:  

```plaintext
.  
├── how_to.md  
├── example  
├── __init__.py  
├── pipeline_class.py  
├── pipeline_def.json  
├── pipeline.dockerfile  
├── README.md  
└── requirements.txt  
```

## Folder Contents

**how_to_guide.md**: a guide showing how to implement the **pipeline_class.py** from scratch.  
**example**: a folder of examples that illustrate the implementation of pipeline classes for performing inspection tasks using varying AI models including object detection, instance segmentation, keypoint detection, classification and anomaly detection.  
**pipeline_class.py**: the implementation of the pipeline class. Several required functions must be implemented.  
**pipeline_def.json**: this file defines the pipeline configurations. It must include a `configs_def` and `model_roles` keys. 
- `model_roles` is a list of model role strings. Check more details in the [model role](#model-roles) section. 
- `configs_def` is a list of custom entries to the configs database. Each element is a dictionary containing two required keys: 
  - `name`: The name of a config.
  - `default_value`: The value of `default_value` must be of a JSON-serializable type.  

**pipeline.dockerfile**: the Dockerfile that defines the pipeline container.  
**requirements.txt**: this file specifies the Python libraries to be installed in the Docker container.  

## Pipeline Class API

The Gadget pipeline class, to be implemented in the **pipeline_class.py**, is responsible for loading configurations (e.g., confidence thresholds, paths to trained AI models, model hyperparameters, etc.), loading and warming up models, making predictions, and cleaning up models. The pipeline class inherits from the [base class](https://github.com/lmitechnologies/LMI_AI_Solutions/blob/trevor_dev/lmi_utils/pipeline_base/pipeline_base.py) to simplify implementation.   
To complete these tasks listed above, the following functions must be implemented in the pipeline class:

1. **def \_\_init\_\_(self, `**kwargs`) -> None:**  
    This function initializes the pipeline class. The `kwargs` argument contains the key-value pairs defined in the **pipeline_def.json**.
2. **def load(self, `models`: dict, `configs`: dict) -> None:**  
    This function loads the models and stores them in the `self.models` variable defined in the base class. The `configs` argument contains runtime key-value pairs, where the keys match those in the **pipeline_def.json** and the values may differ. 
3. **def warm_up(self, `configs`: dict) -> None:**  
    This function receives the `configs` and runs the models for the first time using dummy inputs.
4. **def predict(self, `configs`: dict, `inputs`: dict) -> dict:**  
    This function receives the `inputs` and `configs`, makes predictions, adds annotations to the image, and returns the annotated image along with the model results. Refer to the [Pipeline Inputs](#pipeline-inputs) section for the details of `inputs`. This function must return a `self.results` dictionary defined in the base class.  

This required function has implemented in the base class:

- **def clean_up(self, `configs`: dict):**  
This function receives `configs` and deletes the models from memory.

Additionally, it is recommended that developers define a unit test in the main function within the pipeline class. Refer to the main function of **pipeline_class.py** in the **example** folder for guidance.

## Model Roles
A model role is a part of the inspection process that is associated with a AI model. A single inspection might consist of multiple model roles: an anomaly detector and an object detector. Model roles are defined in GoFactory and are associated with a pipeline in the pipeline_def.json using the **model_roles** key. The key's value must be a list of strings. 

### Loading Models
Models are loaded through the model manager and selected using the model management page of the GadgetApp. Models are either `static` or from GoFactory. GoFactory models are generated by GoFactory and downloaded by the model manager. `Static` models are defined and stored locally. Static artifacts should be stored in the `../static_models` directory and should be configured in the static models `manifest.json`. More information on static models can be found [here](../static_models/README.md)

On load, the `models` dictionary is passed to the pipeline class load method. The dictionary contains the selected model for each model role. The dictionary is structured like this:

```json
{
    "model_role": {
        "format": "pt",
        "configs": {},
        "details": {
            "deployed": str,
            "base_model": str,
            "training_package": str,
            "training_algorithm": str,
            "global_preprocessing": list
        },
        "artifacts": {
            "pt": {
                "image_size": [int, int], # Hight x Width
                "model_path": str # Absolute path to the model
            }
        },
        "model_name": str,
        "model_role": str,
        "model_type": str,
        "model_version": str
    }
}
```

The [LMI_AI_Solutions repo](https://github.com/lmitechnologies/LMI_AI_Solutions) provides wrappers for several of the most popular model architectures. Those wrappers are designed to consume the models dictionary when loading models. 

Example:

The static models

```json
{
    {
        "model_role": "foreground-od",
        "model_type": "ObjectDetection",
        "model_name": "stuff",
        "model_version": "1",
        "format": "pt",
        "artifacts": {
            "pt": {
                "model_path": "./model.pt",
                "image_size": [
                    384,
                    384
                ]
            }
        },
        "details": {
            "training_package": "Ultralytics8",
            "training_algorithm": "Yolo",
            "confidence_threshold": 0.67,
            "object_class": ["object_one", "object_two"],
            "iou": 0.45,
            "object_size": 5,
            "global_preprocessing": []
        }
    },
    {

        "model_role": "forecasting-ad",
        "model_type": "AnomalyDetection",
        "model_name": "Default",
        "model_version": "Default",
        "format": "pt",
        "artifacts": {
            "pt": {
                "model_path": "./model.pt",
                "image_size": [
                    384,
                    384
                ]
            }
        },
        "details": {
            "training_package": "Anomalib0",
            "training_algorithm": "PatchCore",
            "thresholdMin": 3.5,
            "thresholdMax": 5.5,
            "global_preprocessing": []
        }
    }
}
```

would be sent to the load method like this

```json
{
  "foreground-od": {
    "format": "pt",
    "configs": {
      "iou": 0.45,
      "size": {
        "object_one": 5,
        "object_two": 5
      },
      "to-fail": {
        "object_one": true,
        "object_two": true
      },
      "confidence": {
        "object_one": 0.67,
        "object_two": 0.67
      }
    },
    "details": {
      "object_size": 5,
      "object_class": [
        "object_one",
        "object_two"
      ],
      "training_package": "Ultralytics8",
      "training_algorithm": "Yolo",
      "confidence_threshold": 0.67,
      "global_preprocessing": []
    },
    "artifacts": {
      "pt": {
        "image_size": [
          384,
          384
        ],
        "model_path": "/app/models/static/model.pt"
      }
    },
    "model_name": "Default",
    "model_role": "foreground-od",
    "model_type": "ObjectDetection",
    "model_version": "Default"
  },
  "forecasting-ad": {
    "format": "pt",
    "configs": {
      "threshold_max": 5.5,
      "threshold_min": 3.5
    },
    "details": {
      "training_package": "Anomalib0",
      "training_algorithm": "PatchCore",
      "global_preprocessing": []
    },
    "artifacts": {
      "pt": {
        "image_size": [
          384,
          384
        ],
        "model_path": "/app/models/static/model.pt"
      }
    },
    "model_name": "Default",
    "model_role": "forecasting-ad",
    "model_type": "AnomalyDetection",
    "model_version": "Default"
  }
}
```


## Pipeline Inputs

The `inputs` argument of the required **predict** function is a dictionary. It includes an `image` key for data from a single 2D camera imaging system and a `surface` key for data from a single Gocator imaging system. Occasionally, it may also include a `measurement` key for Gocator tool outputs.  
Below is an example of inputs of a two-sensor imaging system (one 2D camera and one Gocator):

```python
inputs = {
    # 2D RGB image
    'image':{
        'pixels': numpy,
    },
    # Gocator 3D data
    'surface':{
        'profile': numpy,
        'resolution': list,
        'offset': list,
    },
    # Gocator tool outputs
    'measurement':{
        'data': dict,
    }
}
```

## Pipeline Outputs - Result Dictionary

The pipeline's **predict** function returns a dictionary following this structure:

```python
{
    # Required 
    "outputs": {
        "annotated": numpy
    },
    "automation_keys": list,
    "factory_keys": list,
    "tags":list,
    "should_archive":bool,

    # Custom
    "key1": VALUE,
    "key2": VALUE,
    "key3": VALUE,
}

```

The key-value pairs in the dictionary must contain literals or lists. No other object types are allowed. The key-value pairs are grouped into two categories: **Required** and **Custom**.

For the **Required** key-value pairs,  

- The `outputs` value is a dictionary that must include an `annotated` key, with its corresponding value being a NumPy array or None. It may also contain additional key-value pairs.
- The `automation_keys` value is a list of strings, which are a subset of **Custom** keys. These keys are sent to the automation service to interact with automation devices, such as PLCs.
- The `factory_keys` value is a list of strings, which are a subset of **Custom** keys consumed by GoFactory. These keys should represent values that are genuinely useful in GoFactory and do not unnecessarily inflate the database size. The values in `factory_keys` populate Grafana dashboards and appear when hovering over a thumbnail on the inspections page.
- The `tags` value should be a list of strings. These tags appear at the top of an event column on the inspections page and can be used to filter results. Ensure `factory_keys` includes `tags` so that this information is also sent to GoFactory.
- The `should_archive` value is a boolean indicating whether to archive the current input. Archiving an image instructs the data manager to move the image from inline storage to offline storage, where it is retained for a longer period.

For the **Custom** key-value pairs, some keys will be used as values for the **Required** keys. The remaining pairs will be saved directly to the database.

Here is an example:  
The result dictionary is stored in a Postgres database:

```python

{
    "outputs": {
        "annotated": np_array,
        "ad_preprocessed": preprocessed_ad,
        "od_preprocessed": preprocessed_od
    },
    "automation_keys": [ "decision", "center_point"],
    "factory_keys":  ["tags", "decision", "score", "total_proc_time"],
    "tags": ["round", "square"], 
    "should_archive": False,

    "decision": ["round", "square"],
    "score": [.98, .95],
    "center_point": [12.5, 5.9],
    "model_proc_time": 85,
    "image_handling_time": 15,
    "total_proc_time": 100,
} 
```

What get sent to automation:

```python
{
    "decision": ["round", "square"],
    "center_point": [12.5, 5.9],
}
```

What get consumed by GoFactory:

```python
{
    "tags": ["round", "square"],
    "decision": ["round", "square"],
    "score": [.98, .95],
    "total_proc_time": 100,
}
```

## Configuring a dockerfile

The pipeline class is run by the **Pipeline Server** which is a python project made of up two whls. 

- gadget_pipeline_server
- gadget_pipeline_adapter

**gadget_pipeline_server** can only run in Python 3.12 but **gadget_pipeline_adapter** can run in any Python 3 version. For standard single python version pipelines the Pipeline Adapter is installed along side the Pipeline Server so there is no noticeable difference to the dockerfile setup. To support multiple versions of python, use python deadsnakes to install the python versions and install the Pipeline Adapter into the new version.

To tell the pipeline server to use a separate python version it must be specified using the ADAPTER_PYTHON_PROCESS env variable. Give it the path to the desired python interpreter. 

````
ADAPTER_PYTHON_PROCESS=/usr/bin/python3.10
````
If left blank it will default to use the same python instance the Pipeline Server is running in.

### Model conversion

To run model conversion **gadget_conversion_utils** must be installed in the same python version as **gadget_pipeline_adapter**. 

To configure the pipeline server to handle conversion requests use the env variable

```
MODEL_CONVERTER=true
```
It defaults to false